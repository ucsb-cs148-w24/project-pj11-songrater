-- Table: public.User

-- DROP TABLE IF EXISTS public."User";

CREATE TABLE IF NOT EXISTS public."User"
(
    id INT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    username character varying(255) COLLATE pg_catalog."default" NOT NULL UNIQUE,
    email character varying(255) COLLATE pg_catalog."default",
    description character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT "User_pkey" PRIMARY KEY (id)
)

TABLESPACE pg_default;


-- Table: public.Song_Info

-- DROP TABLE IF EXISTS public."Song_Info";

CREATE TABLE IF NOT EXISTS public."Song_Info"
(
    song_id character varying(255) COLLATE pg_catalog."default" NOT NULL,
    song_name character varying(255) COLLATE pg_catalog."default",
    artist_name character varying(255) COLLATE pg_catalog."default",
    album_name character varying(255) COLLATE pg_catalog."default",
    year integer,
    genre character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT "Song_Info_pkey" PRIMARY KEY (song_id)
)

TABLESPACE pg_default;


-- Table: public.User_Lists_Good

-- DROP TABLE IF EXISTS public."User_Lists_Good";

CREATE TABLE IF NOT EXISTS public."User_Lists_Good"
(
    user_id integer NOT NULL,
    song_id character varying(255) COLLATE pg_catalog."default" NOT NULL,
    rank integer,
    review character varying(1023) COLLATE pg_catalog."default",
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT song_id FOREIGN KEY (song_id)
        REFERENCES public."Song_Info" (song_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT user_id FOREIGN KEY (user_id)
        REFERENCES public."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION

)

TABLESPACE pg_default;


CREATE INDEX b_tree_idx ON public."User_Lists_Good" USING btree (rank, user_id);

-- Table: public.User_Lists_Ok

-- DROP TABLE IF EXISTS public."User_Lists_Ok";

CREATE TABLE IF NOT EXISTS public."User_Lists_Ok"
(
    user_id integer NOT NULL,
    song_id character varying(255) COLLATE pg_catalog."default" NOT NULL,
    rank integer,
    review character varying(1023) COLLATE pg_catalog."default",
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT song_id FOREIGN KEY (song_id)
        REFERENCES public."Song_Info" (song_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT user_id FOREIGN KEY (user_id)
        REFERENCES public."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE INDEX b_tree_idx2 ON public."User_Lists_Ok" USING btree (rank, user_id);

-- Table: public.User_Lists_Bad

-- DROP TABLE IF EXISTS public."User_Lists_Bad";

CREATE TABLE IF NOT EXISTS public."User_Lists_Bad"
(
    user_id integer NOT NULL,
    song_id character varying(255) COLLATE pg_catalog."default" NOT NULL,
    rank integer,
    review character varying(1023) COLLATE pg_catalog."default",
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT song_id FOREIGN KEY (song_id)
        REFERENCES public."Song_Info" (song_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT user_id FOREIGN KEY (user_id)
        REFERENCES public."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE INDEX b_tree_idx3 ON public."User_Lists_Bad" USING btree (rank, user_id);

-- Table: public.Friend

-- DROP TABLE IF EXISTS public."Friend";

CREATE TABLE IF NOT EXISTS public."Friend"
(
    uid1 INT NOT NULL,
    uid2 INT NOT NULL,
    CONSTRAINT uid1 FOREIGN KEY (uid1)
        REFERENCES public."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT uid2 FOREIGN KEY (uid2)
        REFERENCES public."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;



CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_timestamp
BEFORE UPDATE ON public."User_Lists_Bad"
FOR EACH ROW
EXECUTE PROCEDURE trigger_set_timestamp();

CREATE TRIGGER set_timestamp
BEFORE UPDATE ON public."User_Lists_Good"
FOR EACH ROW
EXECUTE PROCEDURE trigger_set_timestamp();

CREATE TRIGGER set_timestamp
BEFORE UPDATE ON public."User_Lists_Ok"
FOR EACH ROW
EXECUTE PROCEDURE trigger_set_timestamp();